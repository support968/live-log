<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Log</title>

  <style>
    :root{
      --bg:#000;
      --fg:#ff2a2a;
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation 
Mono","Courier New", monospace;
    }

    #term{
      height:100%;
      width:100%;
    }

    #logList{
      height:100%;
      padding:18px;
      overflow:auto;
      white-space:pre;
      font-size:14px;
      line-height:1.35;
    }

    /* top prompt line */
    #promptLine{
      display:flex;
      align-items:baseline;
      gap:8px;
      margin-bottom:10px;
    }

    #promptPrefix{
      display:inline-block;
      min-width:260px;        /* underline length */
      border-bottom:1px solid var(--fg);
      height:1em;
    }

    /* inline input (no white box) */
    #logInput{
      width:260px;
      background:transparent;
      border:0;
      outline:none;
      color:var(--fg);
      font:inherit;
      padding:0;
      margin:0;
      caret-color:var(--fg);
    }

    #lines .line{ color:var(--fg); }
    #lines .err{ opacity:.85; }
  </style>
</head>

<body>
  <div id="term">
    <div id="logList">
      <div id="promptLine">
        <span id="promptPrefix"></span>
        <input id="logInput" autocomplete="off" spellcheck="false" />
        <span id="promptSuffix">is here for communal listening</span>
      </div>

      <div id="lines"></div>
    </div>
  </div>

  <script>
    (() => {
      // ====== CONFIG (Render URL) ======
      const API_BASE = "https://live-log-2h3h.onrender.com";
      const WS_URL   = "wss://live-log-2h3h.onrender.com/ws";

      const list   = document.getElementById("logList");
      const lines  = document.getElementById("lines");
      const input  = document.getElementById("logInput");
      const prefix = document.getElementById("promptPrefix");

      // make underline match input width
      const syncUnderline = () => {
        const w = getComputedStyle(input).width;
        prefix.style.minWidth = w;
      };
      syncUnderline();
      window.addEventListener("resize", syncUnderline);

      const fmt = (ts) => new Date(ts).toLocaleString("en-US", {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: true
      });

      const append = (ts, text, cls="") => {
        const div = document.createElement("div");
        div.className = `line ${cls}`.trim();
        div.textContent = `${fmt(ts)}  ${text}`;
        lines.appendChild(div);
      };

      const animateScrollToBottom = (duration = 900) => {
        const start = list.scrollTop;
        const end = list.scrollHeight;
        const t0 = performance.now();
        const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

        const tick = (t) => {
          const p = Math.min(1, (t - t0) / duration);
          list.scrollTop = start + (end - start) * easeOutCubic(p);
          if (p < 1) requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      };

      const loadInitial = async () => {
        try {
          const res = await fetch(`${API_BASE}/api/messages`, { cache: "no-store" });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const rows = await res.json();

          lines.innerHTML = "";
          rows.forEach(r => append(r.ts, r.text));

          // open motion
          list.scrollTop = 0;
          animateScrollToBottom(900);
        } catch (e) {
          append(Date.now(), "[error] fetch failed", "err");
        }
      };

      // ====== WebSocket ======
      let ws;

      const connectWS = () => {
        ws = new WebSocket(WS_URL);

        ws.addEventListener("open", () => { /* no-op */ });

        ws.addEventListener("message", (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg.type === "message") {
              append(msg.ts, msg.text);
              list.scrollTop = list.scrollHeight;
            }
            if (msg.type === "error") {
              append(Date.now(), `[error] ${msg.message || "unknown"}`, "err");
              list.scrollTop = list.scrollHeight;
            }
          } catch {
            // ignore
          }
        });

        ws.addEventListener("close", () => {
          append(Date.now(), "[error] websocket closed (reconnecting...)", "err");
          list.scrollTop = list.scrollHeight;
          setTimeout(connectWS, 1200);
        });

        ws.addEventListener("error", () => {
          // close will follow; keep minimal
        });
      };

      input.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;

        const text = input.value.trim();
        if (!text) return;

        input.value = "";

        try {
          ws.send(JSON.stringify({ type: "post", text }));
        } catch {
          append(Date.now(), "[error] send failed", "err");
          list.scrollTop = list.scrollHeight;
        }
      });

      // start
      loadInitial();
      connectWS();
      input.focus();
    })();
  </script>
</body>
</html>

